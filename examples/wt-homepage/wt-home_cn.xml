<?xml version="1.0" encoding="UTF-8" ?>
<messages>
  <message id="top_wt">
      <a href="http://www.emweb.be/">
	<img src="/images/emweb_powered.jpg" alt="Emweb" height="22" />
      </a> 
  </message>

  <message id="banner_wrapper">
    <div id="banner_content">
      <div id="banner_end"> <div id="banner"><a href="#">Wt</a></div> </div>
    </div>
  </message>

  <message id="footer_wrapper">
    <div id="footer_content">
      <div id="footer_copyright"> 
	<a href="http://www.emweb.be/">
	  <img src="/images/emweb_large.jpg" height="25" width="101"
	       alt="Emweb.be" title="emweb.be"/></a>
	基于WEB的应用系统解决方案<br/>
	<a href="http://www.emweb.be/">www.emweb.be</a>
      </div>

      <div id="footer_menu"> 
	<a href="http://www.webtoolkit.eu/wt/">首页</a>
	| <a href="http://www.emweb.be/?page=contact">联系我们</a>
      </div>
      <div class="clearall"></div>
    </div>
    <script src="http://www.google-analytics.com/ga.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var pageTracker = _gat._getTracker('UA-4345578-1');
      pageTracker._initData();
      pageTracker._trackPageview();
    </script>
  </message>

  <message id="wt">Wt，C++ 网络开发工具包</message>

  <message id="introduction">简介</message>
  <message id="news">新闻</message>
  <message id="features">特点</message>
  <message id="documentation">文档</message>
  <message id="examples">示例</message>
  <message id="download">下载</message>
  <message id="community">社区</message>

  <message id="hello-world">Hello world</message>
  <message id="charts">图表示例</message>
  <message id="wt-homepage">Wt网站示例</message>
  <message id="treelist">树表</message>
  <message id="hangman">Hangman猜词游戏</message>
  <message id="chat">简单聊天示例</message>
  <message id="mail-composer">邮件编辑器</message>
  <message id="drag-and-drop">拖放示例</message>
  <message id="file-explorer">文件浏览器</message>
  <message id="calendar">日历</message>

  <message id="home.news">
    <h3><span>新闻</span></h3>
  </message>
  <message id="home.latest-news">
    <h4><span>最新消息</span></h4>
  </message>
  <message id="home.historical-news">
    <h4><span>重要消息</span></h4>
  </message>

  <message id="home.intro">

<h3><span>Wt: 简介</span></h3>

<p>Wt(音同'witty')是一个C++库，同时也是开发和部署web应用的服务器。
Wt不是所谓框架(framework)，它只是一个库，它不会将编程方式强加于开发者。</p>

<p>Wt的API是以widget为中心(widget-centric)的，并受到现有C++图形用户界面(GUI)
的应用编程接口(APIs)的启发。Wt为开发者提供了几乎所有web实现细节的抽象，其中
包括事件处理和图像支持。</p>

<p>基于页面的web应用开发框架(Page-based frameworks)，如PHP、JSP/JSF
(+servlets+struts)等，没有实现对一些最基本技术的特性的抽象，这些技术包括
HTML/XHTML、JavaScript、CSS、AJAX、 Forms、DHTML、SVG/VML/Canvas等，显然基
于页面的开发框架(frameworks)必须要求开发者随时熟悉和掌握这些基本技术。另外，
当选择某一种基本技术时(如当前流行的AJAX)，开发者则要对该技术的优雅降级
(graceful degradation)负责，比如当AJAX或JavaScript已经不复存在或某些功能失效
时。同时，应用程序结构还要遵循早期HTML以页面为基础的开发范式。作为一个AJAX开
发者，这就意味着他需要手工设计和维护客户端/服务器端的通讯。</p>

<p>尽管开发者有时不希望，但为了生成HTML代码或填充HTML模板会在页面中插入
JavaScript，如此操作则会带来安全风险，如跨站脚本(XSS:Cross-Site-Scripting)。
但是，模板框架(template frameworks)本身无法避免这种情况的发生，因为开发者总是
需要插入自定义的JavaScript来提高web应用。</p>

<p>相比之下，使用Wt开发的web应用就要好许多，因为这样的应用只使用一种编译
语言(C++)，而且生成必要的HTML/XHTML、Javascript、CGI、SVG/VML/Canvas以及
AJAX代码的任务都交给Wt库完成。自然地，web开发的安全性和浏览器可移植性问题也都
交给了Wt。另外，在可能的情况下，Wt将最大限度地使用JavaScript和AJAX；特别
地，在不支持AJAX的情况下，采用Wt开发的web应用仍能正常工作，因为Wt采用了
转回普通HTML/CGI的机制(reverting to a plain HTML/CGI mechanism)，保证了
浏览器与服务器之间的正常通讯。</p>

<h4>典型应用举隅：</h4>

<ul>
  <li>由于Wt web应用服务器占用较低的内存(low footprint)，故而可以为
  <b>可联网的嵌入式系统(web-enabled embedded systems)</b>提供基于web的图形
  用户界面(GUI)；</li>

  <li>Wt可以为需要<b>整合现有C++库</b>的应用提供基于web的图形用户界面(GUI), 
  这些应用包括科学上的或工程上的应用；</li>
  <li>Wt可以创建从<b>现有C++桌面应用</b>到web的有效渠道(port)。</li>
</ul>

<h4>使用Wt的好处</h4>

<ul>
  <li>可以象开发C++桌面应用一样开发web应用；</li>

  <li>Wt提供最基本的(plain)widgets，这些widgets可以在运行环境不支持
  JavaScript的情况下照常工作(当然，如果支持的话效果会更好)。同时Wt::Ext命名
  空间下的widgets工作效果会更酷(more polished)，而且可以提供更高级的功能，
  但是会需要对JavaScript的支持以及更为流行的浏览器。以上两类widgets在Wt中共享
  同一套应用编程接口(API)；</li>
  
  <li>Wt提供两种开发与部署模式，即使用Wt内置(build-in)httpd或者FastCGI连接器
  (connector)，前者在Wt内较容易实现，而后者则实际上是在开发FastCGI应用；</li>
  
  <li>客户端与服务器端在验证(validation)和事件处理(event handling)方面采用同
  一原则(a single specification)，即两种应用下，开发者在服务器端使用C++编写，
  Wt既在服务器端生成C++代码，又同时在客户端生成JavaScript代码；其中事件处理特
  指使用无状态槽(stateless slot)实现的情况；</li>
 
  <li>可以产生标准的、符合HTML/XHTML规范的代码；</li>
  <li>使用内联VML、SVG、HTML 5 Canvas可以提供可移植的(portable)、抗锯齿图像
  (anti-aliased graphics)；</li>
  <li>无跨站脚本(XSS)风险，因为Wt完全控制表示层(presentation layer)，并提前
  (proactively)过滤掉<i>活动(active)</i> 标签(tags)和属性(attibutes)，这样很好地
  隐藏了驻留在服务器端的业务逻辑(business logic)；</li>
  <li>基于Wt的应用载入时间极短(ultra-fast load time)，同时占用较低带宽
  (low bandwidth usage)，当然也会受到显示内容复杂程度(screen complexity)的影响，
  但肯定不会是应用程序的大小。</li>
</ul>

  </message>
  <message id="home.features">

<h3><span>Wt特点</span></h3>

<h4>核心库</h4>

<ul>
  <li>支持所有主流浏览器(包括Firefox/Gecko、Internet Explorer、Safari、
    Konqueror以及Opera)，同时在不支持JavaScript的浏览器上亦能正常
    工作(已经测试过的有Links和Lynx)；</li>
  <li>开发和部署平台为Unix/GNU Linux (gcc)或者Microsoft Windows
    (Visual Studio)；</li>
  <li>在有无JavaScript或AJAX支持的情况，应用程序行为基本保持一致；</li>
  <li>整合了对UTF8及UTF16的支持；</li>
  <li>提升了AJAX页面变化的渲染(rendering)能力；</li>
  <li>Wt将AJAX页面变化的渲染(rendering)分成可见部分和运行在背景中(隐式)的不可见部分；
    而当不使用AJAX时，只有可见部分被渲染；</li>
  <li>提供可自由配置的会话跟踪(session tracking)选项，这包括URL重写和cookies；</li>
  <li>支持定时事件(timed events)和服务器端发起更新(server-initiated updates)，
    即服务器推送(server push)；</li>
  <li>Wt通过内部地址应用编程接口(internal path API)，可以支持浏览器浏览历史导航
    (即“转到上一页”、“转到下一页”按钮和“书签”功能[注：在IE以上三项称为“向前”、
    “向后”和“收藏夹”])；</li>
  <li>Wt性能卓越，允许部署在低端嵌入式设备(low-end embedded devices)上，或者当用户希望
    其Internet或Extranet应用在功能强弱(energy)、占用空间大小(space)和投入成本(budget)等
    方面达到相对平衡时。</li> 
</ul>

<h4>事件处理</h4>

<ul>
  <li>支持对键盘、鼠标及焦点事件的监听，同时可以获得事件细节，比如鼠标键位、
    键盘键位等；</li>
  <li>Wt使用基于模板的信号/槽系统(template-based signal/slot system)进行事件处理；</li>
  <li>Wt默认采用基于C++的服务器端事件处理，而不是基于JavaScript的客户端事件处理；</li>
  <li>通过详细指明<i>无状态槽(stateless slot)</i>的实现，Wt将动态完成从C++到JavaScript
    的转译；单一C++槽既提供客户端事件处理也提供服务器端事件处理，其结果是客户端引起页面
    视觉效果变化(visual changes)，同时服务器端引起应用状态变化(application state)；</li>
  <li>Wt可以提供自定义JavaScript的钩子(hook)(如仅存在客户端事件处理的情况)，由自定义的
    JavaScript<i>产生(emit)</i>C++信号；</li>
  <li>Wt应用编程接口(API)可以轻松实现拖放(Drag&amp;Drop)功能。</li> 
</ul>

<h4>独有的绘图系统</h4>

<ul>
  <li>Wt绘图应用编程接口(unified painting API)使用内联VML、内联SVG或HTML 5 canvas，
    充分利用浏览器固有的(向量)图像支持； </li>
  <li>绘图系统支持任意路径绘图(arbitrary painter paths)、裁减(clipping)、文本(text)、
    图像(images)、变形(transformations)以及画笔(stroke)和类型填充(fill styling)；</li>
  <li>Wt提供两种绘画系统实现方式，即其API与WPaintedWidget类接合使用，或者直接使用
    SVGImage绘图设备(SVGImage paint device)。</li>
</ul>

<h4>图形用户界面组件</h4>

<ul>
  <li>基本widgets，包括按钮、HTML锚、 选择框、选择按钮、组合框、各种容器(containers)、
    文件上传控制框、图像、标签、文本框(单行/多行)等等；</li>
  <li>表单widgets，内部使用WValidator类支持客户端和服务器端验证；</li>
  <li>复合(Composite)widgets，包括日历、 滚动条、树、树表、菜单、就地编辑(in-place edits)、
    虚拟图像、窗体面板等，这些复合widgets建立在基本widgets之上，并仅使用Wt公共应用编程接口(API)</li>
  <li>Modal视窗，包括对话框和信息提示框；</li>
  <li>使用信息资源集(messages resource bundles)实现内置的I18N；</li>
  <li>Wt采用内联CSS，或者也可以采用内部的或外部指定的样式表；</li>
  <li>Wt Ext widgets，内部使用 <a href="http://extjs.com/">Ext JS 2.0.1</a> JavaScript 
    widgets，ExtJS widgets的大部分子集在Wt中已经打包为(wrapped as) C++ widgets；</li>
  <li>可变的图表(charting)widgets，包括笛卡尔坐标图、饼图等，这些widgets建立在Wt独有的
    绘图系统和Wt MVC架构基础之上。</li>
</ul>

<h4>内置安全性</h4>

<ul>
  <li>Wt采用Kernel级的内存保护方案，特别是在采用专属进程(dedicated-process)模式下，
    会话之间完全隔离，这样Wt完全可以保护隐私数据(privacy issues)免受程序Bug的影响；</li>
  <li>Wt通过在安全超文本传输协议(HTTPS:Secure Hypertext Transfer Protocol)中采用
    安全套接层协议(SSL:Secure Sockets Layer)或者传输层安全协议(TLS:Transport Layer Security)，
    可以支持加密(encryption)和服务器认证(server authentication)；</li>
  <li>能够满足低带宽需求下HTTPS的连续使用，尤其使AJAX获得更佳使用效果(fine-grained AJAX)；</li>
  <li>Wt提供内置的跨站脚本(XSS)安全保护，文本渲染时能自动过滤掉具有潜在风险的恶意代码，
    在Wt应用中使跨站脚本攻击几乎不可能存在。</li>
</ul>

<h4>部署方式</h4>

<h5>a) FastCGI模式特点</h5>

<ul>
  <li>该模式能与多数通用web服务器(如apache, lighttpd)整合在一起；</li>
  <li>提供不同的会话-进程映射(session-to-process mapping)策略；</li>
  <li>支持热部署(Hot deployment)，即新会话使用新的应用版本，同时部署时
    未终止的旧会话仍可以按旧的应用版本继续运行；</li>
  <li>使用多线程编程，可以满足会话内和会话间的请求的同时处理(simultaneous handling of requests)；</li>
  <li>可以使用gdb或valgrind进行调试；</li>
  <li>该模式仅用于UNIX平台。</li>
</ul>

<h5>b) 内置httpd模式特点</h5>

<ul>
  <li>该模式下Wt是简单、高效的web应用服务器，基于C++ asio库，可满足多线程
    (multi-threaded)、异步输入输出(asynchronous I/O)；</li>
  <li>通过OpenSSL库，完全支持HTTP和HTTPS协议；</li>
  <li>支持应答分割与压缩(response chunking and compression)；</li>
  <li>该模式下仅一个进程存在，便于部署和调试；</li>
  <li>既适用于UNIX平台也适用于Win32平台；</li>
  <li>支持通过代理或为了均衡负载的web服务器端部署(deployment behind a 
    ProxyPass'ing (and if needed, load-balancing) web server)。</li>
</ul>

  </message>
  <message id="home.examples">

<h3><span>示例</span></h3>

<p>以下为基于Wt的在线示例：</p>

<p>
  示例的源代码包含在Wt源代码发行版中，同时你可以在每个示例的源码树目录中找到。
</p>

<p>
  示例源代码也以交叉链接(Cross-linked)的形式出现在
  <a href="/wt/doc/examples/html/index.html" target="_blank">
  Wt示例doxygen文档中(自动开启新窗口)</a>。
</p>

  </message>
  <message id="home.examples.hello">
<div>
<br />
<h4>Hello world!</h4>

<p>Wt最基本、最简单的示例:
<a href="/wt/examples/hello/hello.wt">Hello world</a>.</p>

<p>这个示例展示了Wt最基本的概念：</p>
<ul>
  <li>
    如何通过<b>WRun()</b>函数轻松实现(bootstrap)一个Wt应用，在此WRun()函数即为每个新会话创建一个新的
    <a href="/wt/doc/reference/html/classWt_1_1WApplication.html">WApplication</a>对象；
  </li>
  <li>
    <b>如何创建widgets</b>，并把它添加到<b>widget树</b>中；
  </li>
  <li>
    如何使用<b>信号/槽</b>机制响应事件；
  </li>
  <li>
    如何读取widget状态(如，单行文本框)并更新widgets；
  </li>
</ul>

<p>对hello world示例的完整阐述请参见由Victor Venkman撰写的
   <a href="http://www.codeguru.com/cpp/i-n/internet/browsercontrol/article.php/c15275/">Wt介绍</a>。
</p>

<p>源代码：</p>
</div>
  </message>
  <message id="home.examples.wt">
<div>
<br />
<h4>Wt网站示例</h4>

<p>Wt首先为己所用了(We eat our own dog food)，本网站自身即是一个Wt应用实例。 </p>

<p>
  Wt网站主要展示了<a href="/wt/doc/reference/html/classWt_1_1WMenu.html">WMenu</a>
  和<a href="/wt/doc/reference/html/classWt_1_1WTabWidget.html">WTabWidget</a>的使用，
  同时采用不少特性来提高可扩展性(scalability)来减少服务器端资源消耗；另外，Wt网站并不
  是一个非常具有交互性的应用，同时Wt也不推荐这样使用，恰恰相反Wt非常适合于高交互性的
  web开发。
</p>

<p>
  Wt网站还使用了许多菜单widget的特性，比如主菜单，实际是一个纵向(vertical)WMenu的实例化，
  而示例选项卡(tab)，实际是一个使用了WTabWidget实现具有特定样式的横向(horizontal)WMenu。
</p>

<p>
  菜单widget支持对菜单子项目相关内容的<b>预先载入(pre-loading)</b>和<b>滞后载入(lazy loading)
  </b>两种相对模式，同时可以对每个菜单子项目分别<a
  href="/wt/doc/reference/html/classWt_1_1WMenu.html#d7840197cc0caf0430792b9f4a0df60d">指定载入模式</a>。
  需要说明的是，预先载入(pre-loading)不会增加载入时间，因为Wt渲染引擎(render engine)总是首先传输可见的
  widget和某些变化，以此来优化应答时间。不可见部分(如其他预先载入的菜单子项目的内容)则进行隐式传输，
  而且这种传输是在渲染可见部分完成之后进行。
</p>

<p>
  菜单导航栏部分采用C++无状态槽，其实现结果是<b>客户端</b>事件处理。
</p>

<p>
  WMenu类还可以生成<b>内部路径(internal paths)</b>，用于形成浏览器历史记录，
  同时允许加入书签[收藏夹]或者直接指向某个应用状态。当用户通过历史记录浏览时，
  应用可以通过监听WApplication对象的
  <a href="/wt/doc/reference/html/classWt_1_1WApplication.html#41c9bda19b28526e47e70b1b6045e7cf">
  内部路径变化信号(internalPathChanged signal)</a>，直接引起内部路径变化。同样地，
  对于用户将一个URL加入书签中，并在日后重新访问的情况，该信号将在新应用产生后立即被释放。
</p>

<p>
  虽然说Wt占用较少服务器CPU时间，但它确实也需要一部分内存来保持widget状态。当然，如果
  我们能够提供足够的内存(和交换空间)，这将不成问题。另外，由于Wt网站部署在虚拟专用服务器
  (VPS)上，所以我们对此非常小心，并通过
  <a href="/wt/doc/reference/html/classWt_1_1WViewWidget.html">WViewWidget减小内存使用</a>。
</p>

<p>源代码：</p>

</div>
  </message>
  <message id="home.examples.form">
<div>
<br />
<h4>表单示例</h4>

<p>Wt使得获得用户输入变得非常简单，<a
href="/wt/examples/form/formexample.wt">表单示例</a>
展示了各种不同表单widgets的使用。另外，该示例还体现了Wt对<b>表单项验证(validation)</b>和
<b>验证反馈(validation feed-back)</b>以及<b>网站本地化</b>的内置支持。
</p>

<p>
  示例代码展示了以下Wt基本概念：
</p>

<ul>
  <li>
    <i>表单widget</i>继承自<a
    href="/wt/doc/reference/html/classWt_1_1WTable.html">WTable</a>，并将各种不同的
    字段放置在一个网格布局(grid layout)中，其中标签(labels)位于网格的第0列，验证反馈位于第1列，而
    实际的表单字段则位于第2列。
  </li>
  <li>
    <a href="/wt/doc/reference/html/classWt_1_1WValidator.html">WValidator</a>类
    被用来决定字段的内容的验证结果，而且示例中还包含了一个自定义的日期验证器<i>DateValidator</i>。
  </li>
  <li>
    <a href="/wt/doc/reference/html/classWt_1_1WValidationStatus.html">WValidationStatus</a>
    widgets的使用可以不间断地给用户提供验证反馈的结果。
  </li>
  <li>
    示例中<i>城市</i>多选框的内容基于所选的<i>国家</i>值，这个操作依赖国家多选框的信号改变。
  </li>
  <li>
    示例采用<a href="/wt/doc/reference/html/classWt_1_1WMessage.html">WMessage</a>类来显示文本，
    所显示的文本可以是原始文本或者是本地化的文本。对于本地化文本，程序获得一个key值，该值用来
    在基于xml的<b>消息资源集合(message resource bundle)</b>中寻找恰当的文本，在该例中显示为有
    两个可选的语种译文。
  </li>
  <li>
    如上，该示例采用了本地化信息，并可以自动翻译整个应用。
  </li>
</ul>

<p>源代码：</p>

</div>
  </message>
  <message id="home.examples.chart">
<div>
<br />
<h4>图表示例</h4>

<p>
   Wt包含跨浏览器绘图API，并利用浏览器内置的对生成高质量图像的支持，Wt将使用内联VML、内联SVG或者
   HTML 5 canvas 将绘图内容渲染到
   <a href="/wt/doc/reference/html/classWt_1_1WPaintedWidget.html">WPaintedWidget</a>中。
   在<a href="/wt/examples/charts/charts.wt" target="_blank">图表示例</a>中，我们将演示
   <a href="/wt/doc/reference/html/namespaceWt_1_1Chart.html">Wt 图表widgets</a>，这些widgets都
   建立Wt绘图API基础之上。
</p>

<p>
   本示例还展示了Wt的MVC框架，其中的
   <a href="/wt/doc/reference/html/classWt_1_1Ext_1_1TableView.html">
   数据表</a>和图通过同一个
   <a href="/wt/doc/reference/html/classWt_1_1WAbstractItemModel.html">
   模型(Model)</a>建立视图(View)。通过这种方式，模型中的所有变化都将自动反映在视图中，即自动更新视图。
   Wt中模型可以包含字符串(strings)、数字(numbers)以及
   <a href="/wt/doc/reference/html/classWt_1_1WDate.html">日期类型</a>，你可以通过在示例的表中编辑日期
   直接观看到变化。
</p>

<p>
   该示例同时展示了如何轻松使用多种输入widgets、对其输入变化做出反应、设置和读取其内容，以及如何使
   <a href="/wt/doc/reference/html/classWt_1_1WComboBox.html">多选框(WComboBox)</a>与MVC模型关联。
   另外，Wt库能够确保在页面操作时，保持浏览器与服务器之间的数据同步。
</p>

<p>源代码：</p>
</div>
  </message>
  <message id="home.examples.hangman">
<div>
<br />
<h4>Hangman猜词游戏</h4>

<p>
  这款经典的游戏曾被写入<a href="/wt/doc/tutorial/wt-sdj.xhtml">Wt入门</a>中，有点过时了:)
</p>
<p>你可以点击<a href="/wt/examples/hangman/hangman.wt">此处</a>体验。
</p>
</div>
  </message>
  <message id="home.examples.treelist">
<div>
<br />
<h4>树表</h4>

<p>
  该示例通过客户端事件处理实现一个树表widget，大概有350行C++代码。
</p>

<p>
  从1.1.8版开始，更加复杂并富于变化的树widget已经被加入到Wt库中，(参见<a
  href="/wt/doc/reference/html/classWt_1_1WTreeNode.html">WTreeNode</a>
  文档)，该示例只是一个简化版本。
  该示例展示的是如何使用<b>无状态槽</b>实现客户端事件处理，同时想说明使用
  Wt提供的widget时不会受到任何限制，你可以轻松地创建属于自己的高交互性的
  widgets，并可以进行客户端事件处理，还有就是只使用C++语言。
</p>

<p>
  示例中“树叶”上的就是本示例的源代码，其中还包括了<i>WTreeNode</i>和
  <i>IconPair</i>两个类的具体实现。
</p>

<p>
  关于本例更为详细的介绍请参见<a href="/wt/doc/reference/html/example.html">入门</a>
  ，还特别解释了Wt无状态槽机制。
</p>

</div>
  </message>
  <message id="home.examples.treelist-remarks">
<div>
<p>我们能从这个示例中发现什么？</p>
<ul>
  <li> 
    <p>首先，这不是一个预先定义的树表组件的实例，而实际上是由
    <a href="/wt/doc/reference/html/classWt_1_1WImage.html">WImage</a>
    和<a href="/wt/doc/reference/html/classWt_1_1WText.html">WText</a>
    widgets组合实现的, 仅约350行C++代码！相比之下，
    <a href='http://myfaces.apache.org'>Apache MyFaces</a> JSF对tree2的实现，
    相似功能下，却用掉了约2400行的Java代码和约140行的JavaScript代码。
    </p>
  </li>
  <li>
    <p>另外，还可以发现当浏览器支持JavaScript时，树表不需要任何与服务器的交互便
    可完成在 <img src="/icons/nav-plus-line-middle.gif" alt="plus" /> 和
    <img src="/icons/nav-minus-line-middle.gif" alt="min" /> 图标上的鼠标点击事件，
    究其原因是这些事件已经连接到所需要的无状态槽上，而且这些槽已经通过预先学习(prelearned)
    的方式被实现。这样的槽经过优化被直接加进客户端JavaScript代码中，使得即使
    TreeNode::expand()[打开]和collapse()[折叠]方法由纯C++实现都没有问题。
    </p>
  </li>
  <li>
    <p>最后，示例中执行Test map内容的按钮使用的动态连接，在支持AJAX的情况下，
    更新在服务器端处理并发起，然后反馈到浏览器。
    </p>
  </li>
</ul>
</div>
  </message>

  <message id="home.examples.style">
<div>
<br />
<h4>样式示例</h4>

<p>
  HTML/CSS对于增加网页或网站样式非常之方便，在这方面Wt采用内联和样式表两种方式
  使你的程序应用样式。
</p>
<p>
  在<a href="/wt/examples/style/styleexample.wt">该例</a>中我们展示了
  如何创建一个带有圆角的widget类<i>RoundedWidget</i>。因为圆角不是CSS 2的一部分，
  因此现有的解决办法是接合图像使用一些CSS技巧。在该例中，我们使用gd库在特定的颜色
  和半径下动态(on the fly)计算出需要的圆角图片。圆角widget的使用很简单，象wt网
  站中应用菜单一样，其内容就是一个普通的
  <a href="/wt/doc/reference/html/classWt_1_1WContainerWidget.html">WContainerWidget</a>
  ，这个容器widegt中允许被放入其他widgets。
</p>

<p>
  这个示例也向我们展示如何使用
  <a href="/wt/doc/reference/html/classWt_1_1WMemoryResource.html">WMemoryResource</a>，
  该类是抽象类
  <a href="/wt/doc/reference/html/classWt_1_1WResource.html">WResource</a>的具体实现。
  WResource可以称为浏览器请求的目标，用于显示各种文件。特别地，
  <a href="/wt/doc/reference/html/classWt_1_1WImage.html">WImage</a>
  类可以在定义时使用图像资源，如示例中显示的。
  WMemoryResource将从内存位数组中读出的应答以数据流的方式表示，
  <a href="/wt/doc/reference/html/classWt_1_1WFileResource.html">WFileResource</a>
  也将对临时文件以此种方式操作。如果你希望动态计算数据而不是提前计算或将其存储在内存
  或某个文件中，那你可以重新实现WResource。该种应用的实现在mandelbrot示例中可以找到，
  mandelbrot示例实现了对mandelbrot图像的动态计算。
</p>

<p>源代码：</p>
</div>
  </message>
  <message id="home.examples.composer">
<div>
<br />
<h4>邮件编辑器</h4>

<p>
  这是<a href="/wt/examples/composer/composer.wt"> 一个酷似GMail的邮件编辑器
  </a>示例，它更加实际地展示了Wt的各种开发能力。
</p>

<p>
  关于本示例的几点说明：
</p>

  <ul>
    <li>
      与Wt网站相同，该示例仅使用<b>样式表</b>及样式类来精确控制外观。
    </li>
    <li>
      其中的<i>ContactSuggestions</i>类提供了对“抄送地址”和“密送地址”字段的自动补全功能，
      该widget继承自
      <a href="/wt/doc/reference/html/classWt_1_1WSuggestionPopup.html">WSuggestionPopup</a>
      类，该类使用了一些
      <a href="/wt/doc/reference/html/classWt_1_1JSlot.html">JSlot</a>
      对象，这些对象属于槽，与无状态槽不同，其客户端JavaScript事件处理代码由自定义的JavaScript
      指定，而无状态槽的客户端JavaScript则是通过调用“学”到的("learned through invocaiton)。
      运行中联系人表的排序完全在客户端完成，而且其传输隐式进行，原因很简单，即因为他们都
      是不可见的。
    </li>
    <li>
      <i>AttachmentEdit</i> widget展示了<a
      href="/wt/doc/reference/html/classWt_1_1WFileUpload.html">WFileUpload</a>类的使用，
      文件上传允许<b>文件的异步传输</b>，在本例中编辑过程中即开始了附件的上传工作。
    </li>
    <li>
      <i>Option</i>和<i>OptionList</i>类的使用说明了当行为不是完全为无状态时也可以使用无状态槽。
      本例中，对某个Option对象的隐藏动作可以使其相邻的选项形成恰当的分隔距离。虽然状态改变时，
      <b>无状态槽的实现无效</b>，但我们仍可以实现一个无状态槽，并获得客户端事件处理的良好效果。
    </li>
  </ul>

<p>源代码：</p>
</div>
  </message>
  <message id="home.examples.dragdrop">
<div>
<br />
<h4>拖放示例</h4>

<p>
  <a href="/wt/examples/dragdrop/dragdrop.wt">本示例</a>
  展示了拖和放API的使用，拖放功能只能在支持JavaScript或JavaScript有效时使用，因此如果你希望
  拖放支持其他浏览器，那么应当总是记住提供一种替代方案。
</p>

<p>
  在应用中添加拖放功能有三个步骤：
</p>
  <ul>
    <li>
      首先使用<b>WInteractWidget::setDraggable()</b>方法指定一个
      <a href="/wt/doc/reference/html/classWt_1_1WInteractWidget.html">
      WInteractWidget</a>是可拖的，同时你必须选择一种mime类型及相关属性，以说明
      拖事件应该如何被渲染；
    </li>
    <li>
      第二步，放入点自身要声明允许放入的mime类型
      (参见<a href="/wt/doc/reference/html/classWt_1_1WWidget.html#a38">WWidget::acceptDrops()</a>。 
      还需要指定放入点的反馈视觉效果是什么，即当鼠标悬停在放入点上方时如何改变放入点widget的样式，当然
      我们必须保证指定的mime类型是该widget可接收的；
    </li>
    <li>
      最后，放入点重新实现<b>WWidget::dropEvent(WDropEvent)</b>方法，该方法在被放入时调用，提供针对
      指定mime类型和渲染器的实现细节。
    </li>
  </ul>

<p>源代码：</p>
</div>
  </message>
  <message id="home.examples.chat">
<div>
<br />
<h4>简单聊天示例</h4>

<p>
  使用该示例<a
  href="http://www.webtoolkit.eu:1410/simplechat.wt">你可以进行聊天</a>
  ，举个例子，你可以和Wt的开发者及其他感性趣的人聊天。该示例通过客户端和
  服务器端代码实现多用户聊天功能。
</p>

<p>
  该示例展示了如何通过<b>服务器端发起更新</b>来轻松实现多用户互动。
</p>

<p>
  该示例还向你展示了基于类的web部署方法的良好效果，在这种方法中，你可以轻松实现
  对同一widget的多次初始化，示例中的SimpleChatClient widget即可以象使用Wt基本类
  (如按钮)一样，轻松初始化。
</p>

<p>
  象聊天这样的一些交互应用，可以允许用户传输HTML文本给其他用户，众所周知，这非常
  容易引起<b>跨站脚本攻击</b>，因为用户可以不被限制地输入恶意代码(javascript)并作为
  其发出文本的一部分。当对应用户渲染收到的文本时，它可能将从该用户(如浏览器
  cookies)获得的一些隐私信息发送出去。Wt则完全阻止了这样的进攻，同时不会给开发者带来
  负担，因为象WText这样的widgets自然保证了所显示的只有安全文本(passive text)，自动
  舍弃任何严格意义上不是文本的东西。
</p>

<p>源代码：</p>
</div>
  </message>
  <message id="home.examples.fileexplorer">
<div>
<br />
<h4>文件浏览器</h4>

<p>
  你可以在展示<a href="/wt/doc/reference/html/classWt_1_1WTreeTable.html">WTreeTable</a>的示例中
  <a href="/wt/examples/filetreetable/filetreetable.wt">浏览Wt源代码树</a>。
</p>

<p>
  WTreeTable使用
  <a href="/wt/doc/reference/html/classWt_1_1WTreeTableNode.html">WTreeTableNode</a>对象
  组织它的数据，WTreeTableNode继承自
  <a href="/wt/doc/reference/html/classWt_1_1WTreeNode.html">WTreeNode</a>类。
  以上所有widgets继承自
  <a href="/wt/doc/reference/html/classWt_1_1WCompositeWidget.html">WCompositeWidget</a>类，
  因此均使用一套公共Wt API，同时都是纯C++代码，且仅有不多的几行而已。
</p>

<p>
  FileTreeTableNode类重新实现了WTreeNode::populate()方法以获得某个文件夹的内容，当然该获得仍
  是“按需获取”，即我们使用WTreeNode的LazyLoading策略来只载入可见的树节点，当然，下面显示的数表
  中，我们使用了NextLevelLoading策略。
</p>

<p>
  该示例还展示了树(表)的选择支持，具体讲，该示例中我们配置的是扩展选择，只允许文件被选取，
  而不是文件夹。
</p>

<p>源代码：</p>
</div>
  </message>
  <message id="home.examples.calendar">
<div>
<br />
<h4>日历</h4>

<p>
 <a href="/wt/doc/reference/html/classWt_1_1WCalendar.html">WCalendar</a>
 是一个独立(self-contained)的组合(composite)widget的例子，大概330行C++代码。
</p>

<p>
 在此我们演示了这个widget的使用，即用户可以从
 <a href="/wt/doc/reference/html/classWt_1_1WDatePicker.html">WDatePicker</a>中选择
 日期输入到文本框中，也可以采取更直接的方式选定日期(两个实例)，参见
 <a href="/wt/doc/examples/html/Home_8C-source.html#l00397">
 Home::calendarExample()</a>方法代码。
</p>
</div>
  </message>
  <message id="home.examples.calendar.datepicker">
    <p>下面是使用WDatePicker编辑日期字段的示例：</p>
  </message>
  <message id="home.examples.calendar.enter-birth-date">
    请输入出生日期：
  </message>
  <message id="home.examples.calendar.plain">
    <p>简单日历：</p>
  </message>
  <message id="home.examples.calendar.multi">
    <p>可多选的日历：</p>
  </message>
  <message id="home.download">
    <h3><span>下载</span></h3>
  </message>
  <message id="home.download.license">

<h4>许可</h4>

<p>Wt可以在GNU通用公共许可(GPL)或商业许可下使用。</p>

<p>如果你希望在<b>GPL</b>下使用Wt库，那么你可以以任何目的创建web应用，
 并部署在你自己的intranet或Internet服务器上，而不必开放源代码。
</p>

<p>注意，根据GPL条款规定，如果你正以二进制形式将你的web应用转给其他方使用，
 其方式或为销售，或免费提供，此时你必须在发布版上附带程序源代码；同时，这
 一要求亦适用于针对Wt库原始形式或修改形式的再发布。
</p>

<p>所谓<b>商业许可</b>则没有以上限制，具体请访问我们的
 <a href="http://www.emweb.be/?page=license-wt">许可信息</a>
 页面，以获得对许可条款、售价、订购的具体要求。
</p>

<p>注：网站所有中译文，特别是与法律许可等相关的内容最终以英文为准。
</p>

<p>同时，你还可以直接从Wt库作者处获得
 <a href="http://www.emweb.be/?page=services">支持与培训</a>。
</p>
  </message>
  <message id="home.download.requirements">

<h4>系统需求</h4>

为了能够编译和安装最新版的Wt库，你至少需要安装以下两个包：
<ul>
  <li><a href="http://www.cmake.org/">CMake 交叉平台make配置工具</a>。

    <p>建议适用 CMake 2.4 or 2.6</p>
  </li>
  <li>
    必不可少的<a href="http://www.boost.org/"> boost C++库</a>: boost-1.34.1 or boost-1.35.0。

    <p>Wt必需以下boost库: boost_date_time、boost_regex、boost_program_options、boost_signals和boost_thread，
       其中boost_thread可选，但推荐安装。</p>

    <p>如果你正使用 boost-1.35，那么也需要安装 boost_asio and boost_system，
       特别是对于部署方式为内置httpd的应用。</p>
  </li>
</ul>

<p>其他必需部分依赖于你所选择的连接器(connector)支持，连接器是能够实现你的Wt应用与浏览器通讯的工具：</p>

<h5>对于 FastCGI (限于Unix)：</h5>

<ul>
  <li>Apache 1 或 2，或其他支持FastCGI协议的web服务器</li>
  <li>
    <a href="http://www.fastcgi.com/#TheDevKit">FastCGI 开发工具包</a>
    : fcgi-2.4.0
  </li>

   <li>
     使用apache时：
     Apache <a href="http://www.fastcgi.com/dist/mod_fastcgi-2.4.2.tar.gz">mod_fastcgi</a>:
     mod_fastcgi-2.4.2.<br />或者也可以使用
     <a href="http://fastcgi.coremail.cn/">mod_fcgid</a>:
     mod_fcgid-1.07。
  </li> 
</ul>

<h5>对于内置 httpd (wthttpd):</h5>

<ul>
  <li>内置 httpd 需要<a
  href="http://asio.sourceforge.net/">asio C++ 库</a>.

  <p>对于 boost-1.35，它已经包含在其中。对于旧版本的 boost，你需要独立安装asio，
    不过Wt两种均支持，唯一要求boost版本高于0.3.9。</p>
  </li>
 <li>可选部分： libz (用于 compression-over-HTTP) 和 openssl (用于 HTTPS )。</li>
</ul>

你可以依照<a
href="/wt/doc/reference/html/Installation.html">安装指南</a>建立Wt并运行相关示例，
或者如果你的运行平台在<a
href="/wt/wiki/index.php/Wt_Installation">平台相关安装指南</a>中，也可以参照执行。
  </message>
  <message id="home.download.cvs">

<h4>CVS 仓库</h4>

<p>如果你希望跟踪最新的变化，或者参与到Wt的开发中，你可以连接源代码仓库。
  Wt的源码仓库允许匿名CVS访问。</p>

<p>
CVS检出操作：
<div class="fragment">
  <pre class="fragment">$ cvs -d :pserver:anonymous@cvs.webtoolkit.eu/opt/cvs login
  (密码处回车即可)
$ cvs -z3 -d :pserver:anonymous@cvs.webtoolkit.eu/opt/cvs co wt</pre>
</div>
</p>
  </message>
  
  <message id="home.download.packages">
   <h4><span>可用版本</span></h4>
  </message>
  <message id="home.download.version"><b>版本</b></message>
  <message id="home.download.date"><b>日期</b></message>
  <message id="home.download.description"><b>描述</b></message>

  <message id="home.community">
<h3><span>社区</span></h3>

<h4>作者</h4>

<p>
Wt最初由<a
href="mailto:koen@emweb.be">Koen Deforche</a>开发，目前由
<a href="http://www.emweb.be/">Emweb bvba</a>公司维护。</p>

<p>Wt包含了由以下项目借鉴来的代码：</p>
<ul>
<li>Wt内置httpd基于<a
href="http://asio.sourceforge.net/">asio C++库</a>
的一个示例，该库由 Christopher M. Kohlhoff开发(遵循<a
href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License</a>)。</li>

<li>服务器端发起更新(Server-initiated updates)基于
orbited中的JavaScript代码(<a href="http://orbited.org/">Orbited
0.2.0</a>; 遵循<a href="http://www.opensource.org/licenses/mit-license.php">MIT
license</a>)。</li>

<li>线程池实现来自于Philipp Henkel (<a
href="http://threadpool.sourceforge.net/">threadpool</a>; 遵循<a
href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License</a>)。</li>

<li><a href='http://www.minixml.org/'>Mini-XML
2.4</a> 库由 Michael Sweet开发(遵循<a
href="http://www.minixml.org/documentation.php/license.html">Mini-XML license
  </a>，该许可实际为LGPL，只是略有不同)。</li>
</ul>

<h4>Wiki</h4>

<p>
<a href="http://www.webtoolkit.eu/wt/wiki/">Wt Wiki</a>
由社区维护，包括很多有用信息，如针对不同Linux发行版的安装说明等。
</p>

<h4>支持</h4>

<p>你还可以直接从Wt库作者处获得
 <a href="http://www.emweb.be/?page=services">支持与培训</a>。
</p>

<p>另外，你还可以使用<a
href="mailto:witty-interest@lists.sourceforge.net">邮件列表</a>，以获得社区帮助，
(<a href="http://lists.sourceforge.net/lists/listinfo/witty-interest">加入信息</a>)。</p>

<p>你还可以通过<a href="http://gmane.org/info.php?group=gmane.comp.web.witty.general">Gmane
gateway</a>浏览或搜索邮件列表存档内容，特别感谢Pau Garcia i Quiles创建该搜索。</p>

<h4>资助</h4>

<p>Wt的开发得到以下公司或组织的资助：</p>

<p>
<table>
  <tr>
    <td class="sponsor-logo"><a href="http://www.emweb.be/">
      Emweb bvba</a>
    </td>
    <td class="sponsor-role">
      Wt创建者、官方维护者以及相关支持的提供者
    </td>
  </tr>
  <tr>
    <td class="sponsor-logo">
      <a href="http://www.eurofer.be/">
      Eurofer</a>
    </td>
    <td class="sponsor-role">
      Wt图表库开发的资助者
    </td>
  </tr>
</table>
</p>

<h4>献计献策</h4>

<p>我们欢迎用户为Wt献计献策，这可能包括某些widgets的小补丁、widget集以及Wt核心性能提高等。</p>

<p>然而，由于Wt采用开源与商业双重许可，并将Wt作为一个整体在法律上予以保护，
即将Wt作为一个实体，而对于每个部分的版权不予考虑，因此我们在接受用户贡献之前
要求贡献者将版权指认给<a href="http://www.emweb.be/">Emweb</a>
</p>

<p>注：网站所有中译文，特别是与法律许可等相关的内容最终以英文为准。
</p>

<h4>翻译</h4>

Wt网站的中文翻译工作由宋志民协助完成。

<h4>Sourceforge</h4>

<a href="http://sourceforge.net"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=153710&amp;type=1" style="vertical-align:middle" width="88" height="31" border="0" alt="SourceForge.net Logo" /></a>
Wt在Sourceforge的主页请点击<a href="http://sourceforge.net/projects/witty/">此处</a>。
  </message>

  <message id="home.documentation">
 
<h3><span>文档</span></h3>

<h4>编译和安装</h4>

<p>
通用安装指南(UNIX)请点击
<a href="/wt/doc/reference/html/Installation.html">此处</a>，此文档也可
在源文件包中找到，分别为INSTALL或INSTALL.html文件。</p>
<p>

另外，<a href="http://www.webtoolkit.eu/wt/wiki/">Wt Wiki</a> 还有一部分涉及到
<a href="http://www.webtoolkit.eu/wt/wiki/index.php/Wt_Installation">平台相关安装说明</a>。
</p>

<h4>介绍和入门</h4>

<ul>
<li>Dr Dobbs Journal上有一篇很好的<a href="http://www.ddj.com/cpp/206401952">
介绍性文章</a> (2008年2月)。</li>

<li>Software Developers Journal上有一篇入门性文章(
   <a href="/wt/doc/tutorial/wt-sdj.xhtml">在线阅读</a>，
   <a href="/wt/doc/tutorial/wt-sdj.pdf">PDF版</a>)(2006年4月)，稍微有点过时，
   这篇入门文章使用了Hangman猜词游戏示例的代码进行介绍。
</li>

<li>Victor Venkman所写的
   <a href="http://www.codeguru.com/cpp/i-n/internet/browsercontrol/article.php/c15275/">Wt介绍</a>中，对
   <a href="/wt/examples/">hello world 示例</a>进行了测试。
</li>

</ul>

<h4>参考手册</h4>

<p><a href="/wt/doc/reference/html/index.html"
   target="_blank"> Wt参考手册(在新窗口中开启)</a>直接由doxygen从源码中生成，
   手册中也包含了关于树表示例的入门教程，特别是针对无状态槽的实现机制进行了
   说明，另外还强调了Wt允许客户端代码在事件处理中可进一步优化的一些高级特性。
</p>

<h4>注释性示例</h4>

<p>示例的源码级文档也已经制作完成，<a href="/wt/doc/examples/html/modules.html"
target="_blank">在此查看(新窗口中打开)</a>。</p>

<h4>Wiki</h4>

<p>由社区维护的<a href="http://www.webtoolkit.eu/wt/wiki/">Wt Wiki</a>也可以查看，里面有
   很多有用信息，比如FAQ和一些技巧等。
</p>

  </message>
</messages>
